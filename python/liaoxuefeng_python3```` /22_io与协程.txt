io操作如读取文件、发送网络数据，就需要等io操作完成，才能继续下一步操作，这就是同步io。可以使用多进程或者多线程，当前线程被io阻塞并不会
影响其他进程使用。但os并不能无限制增加进线程，且切换进程开销也比较大。引入异步io可以解决这个问题，进程发出io请求后停止程序，等接收到io请求成功后再返回执行。


协程又称微线程。
比如子程序 A、B:
def A():
    print('1')
    print('2')
    print('3')
def B():
    print('x')
    print('y')
    print('z')
假设由协程执行，在执行 A 的过程中，可以随时中断，去执行 B，B 也 可能在执行过程中中断再去执行 A，结果可能是:
1 x 2 y z 3
看起来AB的执行有点像多线程，但协程特点是在一个线程执行的。

最大的优势就是协程极高的执行效率。因为子程序切换不是线程切换， 而是由程序自身控制，
因此，没有线程切换的开销，和多线程比，线程 数量越多，协程的性能优势就越明显。
第二大优势就是不需要多线程的锁机制，因为只有一个线程，也不存在 同时写变量冲突，
在协程中控制共享资源不加锁，只需要判断状态就好 了，所以执行效率比多线程高很多。
因为协程是一个线程执行，那怎么利用多核 CPU 呢?最简单的方法是 多进程+协程，
既充分利用多核，又充分发挥协程的高效率，可获得极 高的性能。

Python 对协程的支持是通过 generator 实现的。



asyncio 是 Python 3.4 版本引入的标准库，直接内置了对异步 IO 的支持。
Python 从 3.5 版本开始为 asyncio 提供了 async 和 await 的新语法;